## 6.1 进程虚拟地址空间

**程序和进程的区别**
+ 程序 (从狭义上讲可执行文件)是一个静态概念，编译好的指令和数据的一个集合。
+ 进程 动态概念，程序运行时的一个过程。

**虚拟地址空间**
+ 虚拟空间大小由计算机硬件决定，具体由cpu位数决定。硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小。
+ 一般c语言的指针大小与虚拟空间的位数相同（指针存储虚拟空间地址）。特殊情况下，这种规则不成立，比如早起的MSC的c语言分长指针、短指针和近指针。
+ 理论上个32位系统，有4GB的虚拟空间，但进程并不能随意使用。
+ 进程的虚拟空间在系统的掌控之中，只能访问系统分配进程的地址。如果访问未经允许的空间，操作系统会捕获这些访问，当做非法操作，结束进程。
    + “Windows下碰到令人讨厌的“进程因非法操作需要关闭”
    + “Linux下的“Segmentation fault”
+ 32位虚拟空间的分配
    + linux下，从地址0xC00000000到0xFFFFFFFF，共1 GB为操作系统占用，剩下的留给用户进程和其他用途。
    + windows下,系统占用2g的虚拟地址空间，有个参数可以调节虚拟占用为1g，即跟liux一样。

     ```
       修改Windows系统盘根目录下的Boot.ini，加上“/3G”参数。

  [boot loader]
    timeout=30
    default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
    [operating systems]
    multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Professional" /3G /fastdetect /NoExecute=OptIn
     ```
**32位cpu下，程序使用的空间能不能超过4GB？**

+ 虚拟地址空间，不能
+ 物理地址空间，可以

从硬件层面上来讲，原先的32位地址线只能访问最多4 GB的物理内存。但是自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存。Intel 把这个地址扩展方式叫做PAE（Physical Address Extension）。

**那么应用程序该如何使用这些大于常规的内存空间呢？**

Address Windowing Extensions 窗口映射

物理地址空间的扩展是操作系统的事，程序是感觉不到的。一个很常见的方法就是操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来。应用程序可以根据需要来选择申请和映射，比如一个应用程序中0x10000000～0x20000000这一段256 MB的虚拟地址空间用来做窗口，程序可以从高于4 GB的物理空间中申请多个大小为256 MB的物理空间，编号成A、B、C等，然后根据需要将这个窗口映射到不同的物理空间块，用到A时将0x10000000～0x20000000映射到A，用到B、C时再映射过去，如此重复操作即可。在Windows下，这种访问内存的操作方式叫做AWE（Address Windowing Extensions）；而像Linux等UNIX类操作系统则采用mmap()系统调用来实现。

用一段指定大小的连续的虚拟地址空间作为窗口，按需在多个等大的物理地址间作映射。

## 6.2 装载的方式
+ 静态装入
  + 指令和数据全部载入内存，缺点：程序所需内存大于物理内存
+ 动态装入
  + 覆盖载入
    + 早期的一种解决方案，程序员手写覆盖管理器，将程序分割成若干块，手工将模块按照它们之间的调用依赖关系组织成树状结构。程序员按需将模块调用路径写入内存。

    + 缺点：禁止跨树调用，所有的调用都经过覆盖管理器，I/O操作频繁，装入速度慢。程序员手写管理代码,工作量大，易出错。
  + 页映射
    + 虚拟存储机制的一部分，通过装载管理器按需将虚拟内存页映射到物理内存页，分配算法FIFO先进先出，LUR最少使用。

    + 这个所谓的装载管理器就是现代的操作系统，更加准确地讲就是操作系统的存储管理器。目前几乎所有的主流操作系统都是按照这种方式装载可执行文件的，我们熟悉的Windows对PE文件的装载及Linux对ELF文件的装载都是这样完成的，接着我们将从操作系统的角度来看可执行文件的装载。

## 6.3 从操作系统角度看可执行文件的装载
虚拟内存页可能被映射到任意物理页，虚拟存储中，现代的硬件MMU都提供地址转换的功能。
### 6.3.1 进程的建立