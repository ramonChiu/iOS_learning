## 4.1 空间和地址分配
### 4.1.1 按序叠加
缺点明显。
段零散，空间浪费，比如对于x86来讲，段的装载地址和空间的对齐单位是页，也就是4096字节，假如一个段就一个字节，会造成巨大的空间浪费。
### 4.1.2 相似段合并
链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。
+ 扫描所有输入文件，获得他们各个段的大小，属性和位置，并将所有输入文件中符号表的符号定义和符号引用都收集起来，并放到统一的全局符号表中。合并相似段，并计算出输出文件中各个段的长度和位置，并建立映射关系。
+ 符号解析和重定位，根据输入文件中段的数据、重定位信息，进行符号解析和重定位、调整代码中的地址等。这是链接过程的核心，特别是重定位。

VMA Virtual Memory Address 虚拟地址
LMA Load Memory Address 加载地址
VMA和LMA通常是一致的，但是在嵌入式系统，特别是放在ROM中程序，LMA和VMA是不相同的，我们应重点关注VMA。
### 4.1.3 符号地址的确定
链接器完成空间和地址的分配后，输入文件中各个段在链接后的虚拟地址已经确定a。
符号相对段首的偏移位置确定为x，符号的虚拟地址=a+x。


## 4.2 符号解析和重定位
在完成空间和地址的分配步骤之后
### 4.2.1 重定位
对引用外部的变量和函数的地址进行修正。
### 4.2.2 重定表
记录哪些指令的哪些部分需要被调整。

对于可重定位的ELF文件，必须包含一个重定位表来描述如何修改相应段里的内容。一个重定位表往往就是一个重定位段。

+ .rel.text 表示代码段的重定位表

+ .rel.data 保存了数据段的重定位表

+ 重定位表的结构是一个Elf32_Rel结构的数组，每个数组元素对应一个重定位入口
Elf32_Reld结构体定义如下：
重定位入口&重定位类型&符号信息
  ```
  typedef struct {
    Elf32_Addr r_offset; // 重定位入口偏移，相对于段首的偏移（目标文件）,在可执行文件和共享文件中表示所修正位置第一个字节的虚拟地址。表示需要重定位的符号的地址。
    Elf32_Word r_info; // 低8位记录，重定位入口类型即寻址方式，高24位记录在符号表中下标-即符号信息。表示需要重定位符号的符号名和类型。

  } Elf32_Rel;

  ```
### 4.2.3 符号解析

重定位过程也伴随着符号解析过程。

+ undefined 未定义类型，这种未定义符号都是因为该目标文件中有关于他们的重定位项。
所以在链接器扫描完所有的输入目标文件之后，所有这些未定义的符号的都应该能够在全局符号表中找到，否则连接器就报符号未定义错误。

+ 每个重定位入口都是对一个符号的引用，当链接去对某个符号引用进行重定位时，它就要确定这个符号的目标地址。
这时候链接器就会去查找所有输入目标文件的符号表组成的全局符号表，找到相应的符号进行重定位。

首先符号解析，在输出文件的全局符号表中找到对应的符号，确定这个符号的目标地址，对引用该符号的重定位地址进行重定位。

### 4.2.4 指令修正方式
近址寻址 & 远址寻址
绝对寻址 & 相对寻址
在32和x86平台下的elf文件的重定位入口所修正的指令寻址方式只有俩种：绝对寻址 和 相对寻址。

重定位类型 即 表示是寻址方法
x86基本重定位类型
+ R_386_32   值1 绝对寻址修正 S+A
+ R_386_PC32 值2 相对寻址修正 S+A-P
  
A 保存在被修正位置的值
P 被修正的位置
S 符号的实际地址

+ 绝对寻址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址。
+ 相对寻址修正后的地址为符号地址距离被修正位置的地址差。

## 4.3 COMMON块
为了解决同一弱符号类型不一致问题，本质是链接器不支持类型识别。

**COMMON块机制**

事实上，现在的编译器和链接器都支持一种叫COMMON块（Common Block）的机制，这种机制最早来源于Fortran，早期的Fortran没有动态分配空间的机制，程序员必须事先声明它所需要的临时使用空间的大小。Fortran把这种空间叫COMMON块，当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准。
+ 多个强符号，类型不一致（符号冲突）
+ 一个强符号，多个弱符号类型不一致（以强符号为准，但如符号空间大于强符号会给出编译警告）
+ 多个弱符号，类型不一致（以所占空间最大为准）

全局未初始化变量，在目标文件中被标记为common类型，而不直接在.bss断中分配空间。因为该弱符号所需大小未知.

当然在最终的可执行文件中，链接器读取所有输入文件以后，弱符号大小被确定，可以再最终的输出文件的.bss端为其分配空间。未初始化全局变量最终被放在.bss段。

**禁用common块机制**
GCC的“-fno-common”也允许我们把所有未初始化的全局变量不以COMMON块的形式处理，
或者使用“__attribute__”扩展：
int global __attribute__((nocommon));

## 4.4 C++相关问题

### 4.4.1 重复代码消除
**产生重代码情况**
+ 模板
+ 虚函数表
+ 外部内联函数

**带来的问题**

+ 空间浪费
+ 地址容易出错
+ 指令运行效率低
  同一份代码多个副本，缓存命中低

###### 解决方案1

+ 将模板代码放在特定段，链接时对不同编译单元的模板代码段去重
+ 外部内联函数和虚函数表做法类似

**遗留问题**

不同编译单元采用的编译器版本和优化选项不同，导致相同函数最终编译结果不同。

**解决方案**

采用任意副本作为输入，并给出警告。

### 4.4.1.1 函数级别链接

VISUAL C++编译期提供了一个个编译选项叫做函数级别链接 Function-Level Linking。
-ffunction-sections 和 -fdata-sections

**作用**

让所有的函数都像前面模板函数一样，但单独保存到一个段里面。
更细的链接粒度，没有用到的函数不会包含在输出文件里。

**优点**

减少输出文件长度，减少空间浪费。

**带来的问题**

+ 减慢编译和链接的过程，目标函数的段的数量大大增加，重定位过程也会因为段的数目增加而变得更加复杂。
+ 目标文件也会因为段的数目增加变得相对较大。

### 4.4.2 全局构造和析构

**全局对象的构造时机**

+ 在main函数之前，为了程序能够顺利执行，需要初始化进程执行环境。
+ 比如堆分配初始化（malloc，free）、线程子系统等。
+ C++全局对象构造函数也是在这一时期被执行。

**析构时机**

main函数之后，程序需要做一些清理工作，然后结束进程。析构函数在此时执行。

**.init**

ELF文件的特殊段进程的初始化代码

**.fini**

ELF文件特殊段保存着进程终止代码。

**机制**

如果一个函数放在.init段，在main函数之前系统就会执行它。
同理，在.fint段，在main函数返回后，该函数就会被执行。
C++的全局构造和析构函数就由此实现，放在对应的段内。

### 4.4.3 C++和ABI


“事实并不像我们想象的那么简单，如果要使两个编译器编译出来的目标文件能够相互链接，那么这两个目标文件必须满足下面这些条件：采用同样的目标文件格式、拥有同样的符号修饰标准、变量的内存分布方式相同、函数的调用方式相同，等等。其中我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI（Application Binary Interface）。”

+ API 源代码级别接口
+ ABI 二进制层面的接口

人们希望二进制的指令和数据能够不加修改地得到重用。

**难点**

“各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI相互不兼容，由于ABI的不兼容，各个目标文件之间无法相互链接，二进制兼容性更加无从谈起”

**c的ABI兼容**

+ 内置类型大小和在存储器中的放置位置。
+ 组合类型的存储方式和内存分布
+ 外部符号和用户自定义符号之间的命名方式和解析方式
+ 函数调用方式
  + 比如参数入栈顺序、返回值如何保持等。
+ 堆栈的分布发方式，
  + 比如参数和局部变量在堆栈里的位置，参数传递方法等。
+ 寄存器使用约定
  + 函数调用时，哪些寄存器可以修改，哪些需要保存，等等。

**C++的ABI兼容性**

语言层面对ABI的影响增加了额外的内容。
+ 继承类体系的内存分布，如基类、虚基类在继承类中的位置等。
+ 指向成员函数的指针的内存分布，如何通过指向成员函数的指针来调用成员函数，如何传递this指针。
+ 如何调用虚函数，vtable的内容和分布方式，vtable指针在object中的位置等。
+ tamplate如何实现
+ 外部符号的修饰
+ 全局对象的构造和析构
+ 异常的产生和捕获机制
+ 标准库的细节问题，RTTI如何实现等
+ 内嵌函数发访问细节

没有统一的C++二进制兼容标准

+ VISUAL C++
+ GNU的GCC 采用intel ltanium C++ ABI标准。
不同的编译期二级制代码之间无法兼容，有时候连同一个编译期的不同版本之间也无法兼容。

## 4.5 静态库链接

把这些零散的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组织方面的不便，于是通常人们使用“ar”压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了libc.a这个静态库文件。

静态库可以看成是目标文件的压缩包。

libc.a中的目标文件基本是一个函数一个目标文件，在链接时仅连接必要的函数。

collect2可以看作是ld链接器的一个包装，它会调用ld链接器来完成对目标文件的链接，然后再对链接结果进行一些处理，主要是收集所有与程序初始化相关的信息并且构造初始化的结构。

## 4.6 连接过程控制

**场景**
+ 系统内核
+ 嵌入式程序
+ 脱离操作系统的，比如硬盘分区软件PQMagic
+ 内核驱动程序
受限于一些特殊条件，需要指定各个段的虚拟地址，名称，存放顺序等。

**几种方式**
+ 使用命令行给ld指定参数，-o,-e
+ 链接指令放在目标文件中
  + “比如VISUAL C++编译器会把链接参数放在PE目标文件的.drectve段以用来传递参数”
+ 链接脚本控制

### 4.6.1 连接控制脚本
```
ENTRY(nomain)

SECTIONS
{
    . = 0x08048000 + SIZEOF_HEADERS;
    
    tinytext  : { *(.text) *(.data) *(.rodata) }

    /DISCARD/ : { *(.comment) }
} 
```
启用该脚本
```
$ gcc –c –fno-builtin TinyHelloWorld.c
$ ld –static –T TinyHelloWorld.lds –o TinyHelloWorld TinyHelloWorld.o
````
输出只有一个段的TinyHelloWorld.o的目标文件。

### 4.6.4 ld链接脚本语法简介

+ 语句之间使用分号“;”作为分割符 原则上讲语句之间都要以“；“作为分割符，但是对于命令语句来说也可以使用换行来结束该语句，对于赋值语句来说必须以“；”结束。

+ 表达式与运算符 脚本语言的语句中可以使用C语言类似的表达式和运算操作符，比如+、?、*、/、+=、?=、*=等，甚至包括&、|、>>、<<等这些位操作符。

+ 注释和字符引用 使用/* */作为注释。脚本文件中使用到的文件名、格式名或段名等凡是包含“;”或其他的分隔符的，都要使用双引号将该名字全称引用起来，如果文件名包含引号，则很不幸，无法处理。
+ 赋值语句比较简单，命令式语句一般是关键字+参数。
+ SECTIONS语句之外其他命令语句比较简单，用于指定链接过程中段的转换过程，这也是链接最核心最复杂的部分。
+ 更多的命令语句的意义及它们的格式请参照ld的使用手册

## 4.7 BFD库
**原因**

由于软件和硬件平台的差别，造成他们的目标文件格式千差万别。对于跨平台的编译器和链接器来说，需要一个统一的接口来处理这些不同格式的目标文件。

**方案**

BFD库（Binary File Descriptor library）就是这样的一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件格式。

BFD把目标文件抽象成一个统一的模型，比如在这个抽象的目标文件模型中，最开始有一个描述整个目标文件总体信息的“文件头”，就跟我们实际的ELF文件一样，文件头后面是一系列的段，每个段都有名字、属性和段的内容，同时还抽象了符号表、重定位表、字符串表等类似的概念，使得BFD库的程序只要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式。

现在GCC（更具体地讲是GNU 汇编器GAS， GNU Assembler）、链接器ld、调试器GDB及binutils的其他工具都通过BFD库来处理目标文件，而不是直接操作目标文件。

**收益**

这样做最大的好处是将编译器和链接器本身同具体的目标文件格式隔离开来，一旦我们须要支持一种新的目标文件格式，只须要在BFD库里面添加一种格式就可以了，而不须要修改编译器和链接器。到目前为止，BFD库支持大约25种处理器平台，将近50种目标文件格式。

## 4.8 本章小结

  本章我们首先介绍了静态链接中的第一个步骤，即目标文件在被链接成最终可执行文件时，输入目标文件中的各个段是如何被合并到输出文件中的，链接器如何为它们分配在输出文件中的空间和地址。一旦输入段的最终地址被确定，接下来就可以进行符号的解析与重定位，链接器会把各个输入目标文件中对于外部符号的引用进行解析，把每个段中须重定位的指令和数据进行“修补”，使它们都指向正确的位置。

  在本章里，我们还对几个静态链接中的问题进行了分析，比如为什么未初始化的全局/静态变量要使用COMMON块、C++会对链接器和目标文件有什么样的要求、如何使用脚本控制链接过程使得输出的可执行文件能够满足某些特殊的需求，比如不使用默认C语言运行库的程序、运行于嵌入式系统的程序，甚至是操作系统内核，驱动程序，等等。




