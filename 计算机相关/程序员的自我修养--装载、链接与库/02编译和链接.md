##### 3.4.3 重定位表

##### 特殊符号
ld链接器符号，可以声明并使用
```
extern char __executable_start[];
extern char etext[], _etext[], __etext[];
extern char edata[], _edata[];
extern char end[], _end[];

```
##### 3.5.3 符号修饰和函数签名
**解决符号冲突**
NameSpace
符号修饰（Name Decoration）或符号改编（Name Mangling）的机制
**C++的符号修饰**
“GCC的基本C++名称修饰方法如下：所有的符号都以“_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾。比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。对于一个函数来说，它的参数列表紧跟在“E”后面，对于int类型来说，就是字母“i”。所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi”

##### 3.5.4 extern “C”
```
extern ”C” {
    int func(int);
    int var;
}
```
兼容C符号，不是用C++的符号修饰，让C符号可以被正确的声明使用

##### 3.5.5 强符号和弱符号
“对于C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号”
可以通过 __attribute__((weak)) 显示声明弱符号。
```
extern int ext;
int weak;
int strong = 1;
__attribute__((weak)) weak2 = 2;
```
在链接时被使用，解决链接时符号冲突的问题
1.重复定义的强符号会报错
2.强符号覆盖弱符号
3.都是弱符号，会选择占用空间较大的弱符号，例如：double A 和 int A，（ps：尽量不要使用不同类型的弱符号，会造成程序错误）

**强引用和弱引用**
+ 强引用
  “须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用”
+ 弱引用
  “在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错”

__attribute__((weakref)) 显示声明对外部符号的弱引用

```
__attribute__ ((weakref)) void foo();

int main()
{
    if(foo) foo();
}
```
这种弱符号和弱引用对于库来说十分有用。
+ 比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数；
+ 或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。
  
#### 3.6 调试信息



