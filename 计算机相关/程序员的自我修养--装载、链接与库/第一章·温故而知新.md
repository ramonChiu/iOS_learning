# 计算机系统
## 1.2 万变不离其宗
**硬件结构的演变**
1. 3个核心部件：cpu & 内存 & I/O控制芯片的基本结构。
2. Bus 总线
    + cpu频率提升，内存跟不上，产生了跟内存频率一致的系统总线，cpu采用倍频方式和总线通信。
3. Northbridge，PCI Bridge
    + 图形设备普及，GPU的快速发展，使得GPU、CPU和内存之间存在大量的数据交换。人们设计了北桥芯片，以便他们之间可以高速的交换数据。
    + 连接几个高速设备，包括内存和PCI总线
4. Southbridge ISA Bridge 
    + 所有低速设备连接到南桥上，然后由南桥汇总到北桥。（南桥芯片 连接低速设备 “磁盘、USB、键盘、鼠标等”）
    + ISA总线 ISA BUS 连接低速设备。
5. 万变不离其宗
    + 基本结构仍然是CPU+内存+I/O

**SMP和多核**


受限于CPU制造工艺，CPU频率的提升达到瓶颈，开始通过提升CPU数量来提升运算性能。

+ “对称多处理器（SMP，Symmetrical Multi-Processing”
    + 多个处理器

+ “多核处理器（Multi-core Processor”
    + 处于成本考虑，多个处理打包成一个处理器，多核共享昂贵的缓存部件。

## 1.3 站得高，望的远
**软件体系的层次结构**
+ 计算机系统软件体系结构采用一种层的结构。计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。

+ 层之间通讯必须有一个通讯协议称之为接口。下层是接口的提供者，由它定义接口。上层是接口的使用者，使用接口功能。

+ 理论上只要层次之间只要遵循接口任何层次都可以被替换。这方便实现硬件和操作系统的向后兼容。虚拟机技术就是增加了一个虚拟层。

+ 应用程序和开发工具层
    + 使用操作系统应用程序编程接口（Application Programming Interface）。接口的提供者是运行时库。Linux下的Glibc的POSIX的API，windows下的Windows API。

+ 运行时库层 runtime Library
    + 使用系统操作系统提供的系统调用接口（System call interface）。系统调用接口在实现中往往以软件中断（Software Interrupt）。Linux用0x80号中断作为系统调用接口，Windows使用0x2E号中断作为系统调用接口。

+ 系统内核层 Operating System kernel
    + 是硬件层的硬件接口的使用者。

+ 硬件层 Hardware
    + 硬件接口往往称为硬件规格（Hardware Specification）。硬件厂商提供规格，系统和驱动程序开发者按照规格开发操作系统和驱动程序。

## 1.4 操作系统做什么
+ 提供抽象接口
+ 管理硬件资源
    + 硬件资源有限，充分发挥硬件潜能。
### 1.4.1  不要让CPU打盹
**cpu调度的演进**
+ 多道程序（Mutiprogarmming）
    + 监控程序监控CPU，当某个程序不适用CPU时，把在等待CPU资源的程序启动。比较原始，调度策略粗糙，没有轻重缓急。
+ 分时系统（Time-Sharing System）
    + 协作模式，每个程序运行一段时间后都主动让出CPU给其他程序。这对一些交互式的任务尤为重要。wind95和win NT之前，Mac OS X之前都采用这种分时系统。

    + 稍微演进，监控程序更加复杂。

    + 存在问题：如果一个程序进行耗时计算，一直霸着CPU不放，其他程序必须等着，整个系统看着像进入死机状态。如while（1）。
+ 多任务系统 （Muti-tasking）
    + 操作系统接管所有硬件资源。
    + 操作系统运行在一个受硬件保护的级别，应用程序以进程process的方式运行在比操作系统更低权限的级别。
    + 进程独立地址空间，地址空间隔离。
    + cpu由操作系统统一调度，根据进程优先级都有机会得到cpu，但运行超出一定时间，系统会暂停该程序，将cpu分配给等待的进程。

    + 这种CPU的分配方式是抢占式（Preemptive）。操作系统可以剥夺CPU资源并分配给它认为目前最需要的进程。

### 1.4.2 设备驱动

操作系统作为硬件的上层，它是对硬件的管理和抽象。
成熟的操作系统，硬件被抽象成一系列概念。避免程序编写者对纷杂硬件的直接操作（端口、操作方式、访问方式不一）。

+ UNIX系统，硬件设备的访问跟普通文件的访问一样。
+ windows系统中，图形硬件被抽象成了GDI，声音和多媒体被抽象成了DirectX对象，磁盘被抽象成了普通文件系统。

繁琐的硬件细节交给操作系统，具体是交给硬件驱动（Device Driver）程序。驱动程序运行在和操作系统内核一样的特权级，并保留独立性，更灵活适配。
操作系统开发者为硬件生产厂商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。

**文件读取**

从文件读取看系统访问设备的过程。

扇区&盘片&磁道。

摒弃硬件细节，抽象为LBA （Logical block Adress）。给出一个逻辑扇区号，硬盘的电子设备将它转换为实际盘面、磁道等位置。

文件系统将文件写入磁盘，保存了这些文件的存储结构，负责维护这些数据结构并保证磁盘中的扇区能够有效的组织和利用。

假如：读取文件的前4096字节位于磁盘的1000-1007号逻辑扇区。
+ read系统调用
+ 文件系统收到read请求并向磁盘驱动发出一个从1000开始8个扇区的请求。
+ 驱动向硬盘发出硬件指令。
    + 硬件的I/O命令有很多种，最常见的一种是通过I/O端口寄存器。
    + x86平台有65536个硬件端口寄存器，不同的硬件被分配不同的I/O端口。
    + CPU提供给了俩条指令in 和 out 来对硬件端口读写。

    + IDE接口有俩个通道，IDE0和IDE1，分别为Master和Slave，一个PC最多可以有四个IDE。

    + 在PC中，IDE0通道的I/O端口地址是0x1F0～0x1F7及0x376～0x377。通过读写这些端口地址就能与IDE硬盘进行通信。

    + 第0x1F3～0x1F6 4个字节的端口地址是用来写入LBA地址的，那么1000号逻辑扇区的LBA地址为0x000003E8，所以我们需要往0x1F3、0x1F4写入0x00，往0x1F5写入0x03，往0x1F6写入0xE8。

    + 0x1F2 写入扇区数 8
    + 0x1F7这个地址用来写入要执行的操作的命令码，对于读取操作来说，命令字为0x20。
+ 硬盘收到这个命令后，就会执行相应操作，并将数据读取到事先设置好的内存中。

##  1.5 内存不够用怎么办？

早期程序直接访问物理的地址的弊端
+ 安全性，地址不隔离，恶意程序可以修改其他程序的数据。
+ 效率，有限的内存空间可能导致大量的数据换入换出。
+ 编写程序麻烦，每次载入内存的地址不固定，访问数据和指令跳转的目标地址需要重定位。

方案：
增加中间层，间接地址访问，虚拟地址（virtual address）。
### 1.5.1 关于隔离

程序不希望介入复杂的存储器管理。需要一个执行环境，一个地址空间，一个CPU，好像这个程序占用整个计算机而不关系其他程序。

个人感觉这里也可以是面向抽象的一种体现，把物理地址抽象为虚拟地址，简单认为整个内存地址都可以被我使用，摒弃复杂物理地址管理。

虚拟地址空间由cpu位数决定，跟实际的物理地址空间不符。

每个进程都有自己的虚拟地址空间，且只能访问自己的地址空间，这样就有效的实现地址隔离。

### 1.5.2 分段 Segmentation

















